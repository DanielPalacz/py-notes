<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Bootstrap CSS -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">

    <style>
    * {
      box-sizing: border-box;
      font-family: 'Montserrat', sans-serif;
    }

    table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
    }
    th, td {
      padding: 5px;
      text-align: left;
    }
    .main-a {
      font-size: 30px;
<!--      color: #000;-->
    }
    .row {
        margin: 20px 20px 20px 20px
    }


    .button-link-custom {
        font-size:30px;
    }

    .button-link-custom:hover {
        transform: scale(1.02); /* Slightly enlarge the brand */
        box-shadow: 0px 6px 12px rgba(0, 0, 0, 0.2);
        color: yellow;
    }



    .card {
        background-color: #d0e7f7;
        border-radius: 8px;
        transition: all 0.3s ease;
        box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1);
        border: 2px solid #000;
    }

    .card:hover {
        transform: scale(1.02); /* Slightly enlarge the brand */
        box-shadow: 0px 6px 12px rgba(0, 0, 0, 0.2);
    }

    .card-body {
		padding: 0px;            /* Internal padding */
		margin: 10px;            /* Internal margin */
		color: #000;
    }

    .card-body a {
		color: #000;
		text-decoration: underline;
    }

    .shell {
    	color: #555;
    }

    .code {
    	color: green;
    	font-style: italic;
    }

    .todo {
        color: yellow;
        background-color: #000;
    }
    .yellow-this {
        background-color: yellow;
    }

    .notion {
    	color: #9370DB;
    	font-style: italic;
<!--    	font-weight: bold;-->
    }

    .notion-explanation {
    	color: #9370DB;
    	font-style: italic;
    }


</style>

</head>
<body style="color:black;background-color:powderblue;">

<br>
<div class="row">
    <div class="col-md-8">
            <div class="card mb-4 box-shadow" style="background: yellow;">
                <h2 class="ml-2"><b><u>Python questions / observations:</u></b></h2>
                <div class="card-body">
<br>

<b style="background: #ADD8E6;">PROTOCOLS:</b>
<br>
<br>
<ol start="31">
        <li>Python as protocol oriented language. There is set of behaviours implemented as Protocols in Python, but to be Protocol oriented language? It is probably not enough.</li>

        <br>

        <li>[Descriptors protocol]: Python Descriptor object is class attribute self-defining way of accessing it in instance level scope (using: __get__, __set__, __delete__).</li>
        <ul>
            <li>Python is deeply equipped with Descriptors (fe: functions, methods, properties, class methods, static methods, super).</li>
            <li>Descriptors have effects when defined as class variables and when called from instance scope. When created in instances, they have no effect. But also descriptors logic is not triggered from classes scope.</li>
                <li>Python Descriptors Nature is by design being "properties" (they are "attached" to instances). Descriptors control instance attributes. Metaclasses control class attributes.</li>
            <ul>
                <li>The mechanism for descriptors is embedded in the __getattribute__() methods for object, type, and super(). There are nuances in terms of descriptor invocation logic in these implementations. For example, Instance lookup scans through a chain of namespaces giving data descriptors the highest priority, followed by instance variables, then non-data descriptors, then class variables, and lastly __getattr__() if it is provided.</li>
                <li>__set_name__ hook is called during class creation extends capability of descriptor objects.</li>
            </ul>
        </ul>
        <br>
        <br>

        <li>[Attribute lookup protocol]: Attribute lookup for Class, Instance, Super:</li>
<pre style="notion">

In high level it is such mechanism:
    try:
        [type, object, super].__getattribute__(...)
    except AttributeError:
        [type, object, super].__getattr__(...)

Potential modifiers:
 - Descriptors
 - Metaclasses
 - __slots__ functionality</pre>

Use cases:
    <table>
        <tbody>
        <td>
        <pre>
1. Instance objects
  - lookup for instance attribute
  - lookup for class attribute
  - object.__getattribute__ (def)</pre>
        </td>
        <td>
        <pre>
2. Class objects:
  - lookup for class attribute
  - type.__getattribute__ (def)</pre>
        </td>
        <td>
        <pre>

3. Super object executes lookup:
  - from Instance object for instance/class attribute
  - from Class object for instance/class attribute
  - by default super().__getattribute__ is taken
        </pre>
        </td>
        </tbody>
    </table>
</ol>

<br>
    <b style="background: #ADD8E6;">Functions Deep Dive:</b>
    <br>
    <br>

    <ol start="34">
        <li>Functions are objects, but not so-typical. What makes functions not typical objects?</li>
<pre>

1. Functions local scope is built different:
 - Function local scope exists in runtime and is built based on temporarily created Stack Frame,
 - this Frame leverages the data from funct.__code__ for creating local scope
 - If we have look into temporarily created Frame (named F) then:
    - we can check that: F.f_locals is locals() => gives True
    - so Python Frame Stack is used to build Function local scope
2. Functions have a __code__ object storing function bytecode.
3. Functions have a __dict__ used bit different, only for storing attributes (what is kind of specific functions behaviour).
4. Functions support closure pattern (__closure__ remembers variables from outer scope). Fundamental mechanism for predictability.
5. Every function written in Python is Non-Data Descriptor (when C based not).</pre>

<br>
    <li>Tricky edge case for imports in Class when code is C-based. How creating Bound Method works here?</li>
<pre>
class A:
    from json import dumps as g # written in Python and defines __get__ (however there can be 2 implementations: Python/C)
    from itertools import repeat as h   # it is callable class written in C, doesn't define __get__

Notes:
 * During Runtime when 'class A' is created, class body-content is being executed line by line (like function).
 * A.g("xx")   - ok
 * A.h("xx")   - ok
 * A().g("xx") - TypeError: dumps() takes 1 positional argument but 2 were given
 * A().h("xx") - ok
 * @classmethod impact
</pre>

</ol>



<br>

<b style="background: #ADD8E6;">Testing things:</b>
<br>
<ol start="36">
        <li>Mock and Stub what is the difference? Other test doubles: Dummy, Fake, Spy</li>
<pre>
Mock:
  - It should be used for verifying interactions, ensuring the correct methods are called with the expected parameters.
  - Mocks can be configured to throw exceptions, return different values for different calls, and so on (can be complex).
Stub:
  - this test double focuses on providing data (predefined responses) to control the test environment
  - often used to simulate the behavior of external services or components (isolating dependencies)

    => Both stubs and mocks help isolate the code under test by replacing external dependencies with controlled behavior.

Dummy
 - the simplest form of a test double. It is an object that is passed around but is never actually used (serves as a placeholder)
 - Dummies are used when an argument is required by the code being tested, but it’s not actually used during the test.
Fake
 - test double that has working implementations but is simplified or not as performant as the real system
 - Fakes are used when a real system might be too complex or slow, but you still want some kind of working implementation
Spy
 - more advanced type of test double that not only helps verify interactions (like a mock) but also records the calls made to it
Fixture
 - In the context of testing, fixtures can be considered as part of the broader test double or test setup family.
 - Any setup or configuration required to run your tests. Ensuring that the necessary context is available for the tests to execute.
 - Typically includes the creation of test data, that can be even related to setting up a connection to a database or web server.
 - Fixtures are about test setup and teardown — while test doubles isolate/control behavior of components within that environment.

Test Doubles (Mocks, Stubs, Fakes, etc.):
 - Used to replace or simulate specific parts of a system, like dependencies or external services, that your code interacts with.
 - They help isolate/control the code under test and allow you to control behaviors and verify interactions.

</pre>
        <li>Mocking frameworks: unittest.mock, when to use MagicMock and when Mock?.</li>
<pre>
Use Mock when:
 - You only need to mock regular methods or attributes that are not related to magic methods (i.e., methods you define yourself).
 - You don't need support for special behavior like indexing, iterating, or arithmetic operations.

Use MagicMock when:
 - You need to mock magic methods (__getitem__, __setitem__, __call__, __iter__, etc.) or objects involved in such operations.
 - You deal with objects that emulate builtin containers like lists, or objects that need to support special methods in your tests.</pre>
        <br>
        <li>Mocking vs patching? What is difference?</li>
        <br>
        </ol>

        </div>
    </div>
</div>
    


</body>
</html>


