<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Bootstrap CSS -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">

    <style>
    * {
      box-sizing: border-box;
      font-family: 'Montserrat', sans-serif;
    }

    table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
    }
    th, td {
      padding: 5px;
      text-align: left;
    }
    .main-a {
      font-size: 30px;
<!--      color: #000;-->
    }
    .row {
        margin: 20px 20px 20px 20px
    }


    .button-link-custom {
        font-size:30px;
    }

    .button-link-custom:hover {
        transform: scale(1.02); /* Slightly enlarge the brand */
        box-shadow: 0px 6px 12px rgba(0, 0, 0, 0.2);
        color: yellow;
    }



    .card {
        background-color: #d0e7f7;
        border-radius: 8px;
        transition: all 0.3s ease;
        box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1);
        border: 2px solid #000;
    }

    .card:hover {
        transform: scale(1.02); /* Slightly enlarge the brand */
        box-shadow: 0px 6px 12px rgba(0, 0, 0, 0.2);
    }

    .card-body {
		padding: 0px;            /* Internal padding */
		margin: 10px;            /* Internal margin */
		color: #000;
    }

    .card-body a {
		color: #000;
		text-decoration: underline;
    }

    .shell {
    	color: #555;
    }

    .code {
    	color: green;
    	font-style: italic;
    }

    .todo {
        color: yellow;
        background-color: #000;
    }
    .yellow-this {
        background-color: yellow;
    }

    .notion {
    	color: #9370DB;
    	font-style: italic;
<!--    	font-weight: bold;-->
    }

    .notion-explanation {
    	color: #9370DB;
    	font-style: italic;
    }


</style>

</head>
<body style="color:black;background-color:powderblue;">

<br>
<div class="row">
    <div class="col-md-8">
            <div class="card mb-4 box-shadow" style="background: yellow;">
                <h2 class="ml-2"><b><u>Python questions / observations:</u></b></h2>
                <div class="card-body">
<br>
<b style="background: #ADD8E6;">ITERABLES / ITERATORS / SEQUENCES:</b>
<br>
<br>
    <ol>
        <li>Iterator and Iterable objects implementing certain protocols. What are details of these protocols?</li>
        <pre class="code">
Iterator protocol:
 - Iterator object needs to implement __iter__ and __next__.
   Main feature of Iterators is allowing for sequence access of data stream - no need to maintain all data in memory.

Iterable protocol:
 - Iterable object should implement __iter__, but not it is not requirement if there is no __iter__ then __getitem__ is required.
   In the other words iter(Iterable_object) should always produce valid Iterator object.

Dict objects are Iterable, but are not Iterators:
>>> hasattr(dict(), "__iter__")
True
>>>
>>> hasattr(dict(), "__next__")
False
>>>
>>> hasattr(dict(), "__getitem__")
True # However it is not implementing Indexing/Slicing
>>>
>>> iter(dict())
dict_keyiterator object at 0x7d7e055eba10
    => dict objects are Iterables (but are not Iterators and Sequences)</pre>


<pre class="code">
"__getitem__ edge case":
    In Python 3 builtin collections are generally implement __iter__. However:
     - Still it is possible to create a class that have only __getitem__ and not __iter__ and such object will be Iterable.
     - It is rather hack than common practice, but handling __getitem__ in Iterable protocol still works.</pre>
<ul>
    <li><a href="python_deepness/protocols/iterable_without_iter_dunder_method.py">example (iterable_without_iter_dunder_method.py)</a></li>
</ul>

        <br>
        <li>What are builtin Iterable data structures that are also Iterators (have __next__ and __iter__)?</li>
        <div> - map, filter, reduce, zip - map example:</div>

            <pre class="code">
>>> L = [0, 2, 4, 6, 8]
>>>
>>> mapped_L = map(lambda x: x + 1, L)
>>>
>>> mapped_L
map object at 0x70d609f84a60
>>>
>>> hasattr(mapped_L, "__iter__")
True
>>> hasattr(mapped_L, "__next__")
True
>>> hasattr(mapped_L, "__getitem__")
False
    => map objects are Iterables and Iterators (but not Sequences)
</pre>

        <li>What are details of sequence protocol in Python?</li>
            <pre class="code">
Sequence objects in the most basic version need to implement two dunder methods: __getitem__, __len__:
 - __getitem__, __len__ are base for Indexing and slicing functionalities.
 - __getitem__ from dict doesnt allow Indexing and Slicing, so having __getitem__ is not enough, implementation matters.
 - In more complete version also methods: __contains__, __iter__, __reversed__, index and count.

All Sequences are also Iterable, but not opposite.

Range object example:
>>> R = range(3)
>>> type(R)
&lt;class 'range'&gt;
>>> hasattr(R, "__getitem__")
True
>>> hasattr(R, "__len__")
True
>>>
>>> R[1]
1
>>> hasattr(R, "__iter__")
True
>>> hasattr(R, "__next__")
False
    => range objects are Sequences and Iterables, but not Iterators
</pre>

        <hr>
        <hr>
        <hr>
        </ol>
<br>
<b style="background: #ADD8E6;">GENERATORS:</b>
<br>
<br>
        <ol start="4">
        <li>The final truth about generators, when they are really useful and when not? How generators cooperate with Python Frame based Stack? Do Class-based Iterators use Python Frame based Stack?</li>
<pre class="notion">
 - Generatory są świetne, gdy nie znamy górnej granicy zbioru lub przetwarzamy tylko część wyników,
   np. sekwencję Fibonacciego, liczby pierwsze czy duże pliki CSV linia po linii. Generatory są niepraktyczne, gdy
   potrzebujemy przechowywać i przetwarzać cały zbiór naraz – np. jeśli chcemy posortować duży plik danych,
   lepiej wczytać go do listy, bo generatory nie pozwalają na swobodny dostęp do elementów.
 - W przeciwieństwie do zwykłych funkcji, generatory nie usuwają swojej ramki po zakończeniu wywołania yield.
   Zamiast tego, stan wykonania (w tym zmienne lokalne i wskaźnik kodu) jest przechowywany w obiekcie generatora.
   Mechanizm yield powoduje, że zamiast usunięcia ramki stosu (w normalnej funkcji), Python zapisuje jej stan i zawiesza wykonanie.
   Kiedy generator jest wznawiany, ramka zostaje przywrócona na stos i kontynuuje działanie od miejsca yield.

 - Trzy przykłady przepływów w Generatorach:
    1)
        * x = yield
        * Ta forma oznacza "czekaj na wartość z send(value)".
          Kiedy coroutine zostaje uruchomiona i napotka 'x = yield', wtedy "zawiesza się" i oczekuje na dane z GEN_OBJ.send(value).
    2)
        * yield x
        * Ta forma oznacza: Zwróć wartość x na zewnątrz — to właśnie wynik next() lub send(...)
    3)
        * y = yield x
        * Mix 1 i 2.
</pre>

        <li><b>yield from ITERABLE_OBJECT</b></li>
 <pre>
  - The one benefit of yield from is to allow easy refactoring of generators.
  - The second "performance optimization" is even more important. Simulation showed "yield from" speeds up execution about 10-30%.

  - O tej funkcjonalności można powiedzieć sporo więcej:

     -- Przykład: Rekurencyjna iteracja po strukturze drzewiastej
     -- Przykład: Dwukierunkowa komunikacja z yield from

     -- Python poszedł tu nieco pod prąd i dodał coś, czego brakuje w innych językach.
        Można to uznać za niekonwencjonalne, ale to dobrze wpisuje się w filozofię Pythona: mniej kodu, większa czytelność.
     -- Python często dodaje konstrukcje, które upraszczają kod, nawet jeśli wydają się „magiczne”.
        Czasem wydaje się, że Python chce być bardziej jak DSL (Domain-Specific Language)
        dla każdej możliwej sytuacji, a nie czysto „przewidywalnym” językiem ogólnego przeznaczenia.

     y = yield from sub_generator()
        - automatycznie iteruje przez cały sub_generator(), wszystkie yield z tamtego trafiają "na zewnątrz",
        - a jeśli sub_generator() zakończy się return coś, to yield from zwraca tę wartość do y.

 </pre>

        <li>Why and when such error happened with generators?<span> <b>TypeError: can't send non-None value to a just-started generator</b></span></li>
            <ul>
                <li>It occurs when you attempt to send a non-None value into a generator that has not yet been started (i.e., before its first yield statement).</li>
                <li>By design, the first .send(value) call must be None or the generator must be primed using next() first.</li>
                <pre class="code">
gen = accumulator()
gen.send(10)  # ❌ TypeError: can't send non-None value to a just-started generator</pre>
            </ul>
        <hr>
        <hr>
        <hr>
</ol>
<br>
<b style="background: #ADD8E6;">MISCELLANEOUSNESS:</b>
<br>
<br>
<ol start="7">
        <li>What are some different characteristics of Functions/Classes Nature?</li>
<pre class="notion">
 - Classes can be seen more like containers/structures/blueprint when functions are set of instructions (executable code blocks).
 - A class definition is a 'Declaration of a Structure', not a sequence of instructions (like functions).
 - While you can inspect the bytecode of class methods, the class object doesnt have bytecode associated to be disassembled.
    * That code can be disassembled, but it's part of the higher-level object and it is not attached to the final class object
 - Python classes are highly dynamic (add, remove, modify attributes at runtime). This flexibility comes at performance cost.
 - Classes due protocols/hooks are very modifiable during creation time. It also costs.
Then:
 - In Classes Nature is to be very modifiable containers/blueprints. When Functions Nature is to be lightweight set of instructions.</pre>
        <li>It was possible to compare some very specific solutions in terms of speed (by not realistic micro-benchmarking, but at least something). First solution based on functions and second based on classes. In the result class-based solution was 100 times slower. Why classes could be so slow? What are the biggest factors here? Additionally, in tests were seen that __slot__ classes feature did not improve speed, but tests were limited so this result could be not reliable.</li>
<pre class="notion">
 - Creating a function is a simpler operation than creating a class. Python's interpreter is optimized for function creation.
 - Classes, even empty ones, have more overhead due to their inherent complexity.
 - Class creation flow is much more complex: Metaclass handling, namespace creation or executing class body code. It all takes time.</pre>
        <br>
        <li>Why immutable types were created in Python? There can be mentioned few reasons, but one can be that "it was needed for more complex data structures". The word about Hash maps, dictionaries, scopes/namespaces.</li>
        <li>What are cases in Python where internal state (implementation details) are hidden from users?</li>
<pre class="code">
 - lru_cache / cached_property
 - weakref module
 - asyncio / threading
</pre>
        <br>
        <li>MappingProxy / FrozenSet / NamedTuple / Arrays / Deque / SimpleNamespace - why/when these structure can be useful?</li>
        <br>
        <li>Unicode and UTF-8 are default in Python 3, but what does it really mean? Unicode is universal symbol representation system - it contains all world alphabets and also other symbols like emojis. When UTF-8 is Unicode symbols coding system to bytes form.</li>
<pre class="code">
Unicode / UTF-8 example:
    Unicode mapping:
      chr(300) => Return a Unicode string of one character with ordinal i; 0 <= i <= 0x10ffff.
      'Ĭ'
      ord('Ĭ') => Return the Unicode code point for a one-character string.
      300
    UTF-8 encoding:
      bytes('Ĭ', "UTF-8") # Zwraca bajty reprezentujące znak Ĭ w kodowaniu UTF-8.
      b'\xc4\xac'         # 0xC4 0xAC => 11000100 10101100 => To są 2 bajty reprezentujące znak Ĭ w UTF-8.
</pre>
        <li>Python float implements IEEE 754, so float64 precision (53 bit mantis). 2**53 is the biggest number represented accurately.</li>
        <br>
        <li>In Python str class there are maketrans (static method) and translate methods. It can be useful for converting text and removing specific symbols.</li>
        <br>
        <li>Ellipsis it is unique constant accessed globally in Python (instance of EllipsisType). When we can use ellipsis object?</li>
        <br>

        <li>Python 'import module_A' and Python Execution model. In terms of module importing what happens during Parsing Stage, Compilation Time and Runtime? What if there is second the same import?</li>
        <pre>

 1. Parsing Stage
        - Najpierw Python czyta główny plik np 'script.py' lub .pyc jeśli kod już jest skompilowany.
        - Na tym etapie nie wykonuje import module_A tzn NIE wczytuje module_A.py i nawet nie sprawdza, czy ten plik istnieje.
        - Linia import module_A po prostu zostaje zapisana w AST (potem bytecode) jako instrukcja do późniejszego wykonania.

        - Podsumowując, na tym etapie Python NIE parsuje kodu module_A.py podczas parsowania script.py.
          Parsowanie każdego modułu dzieje się dopiero, gdy interpreter faktycznie wykona instrukcję import w czasie Runtime.

 2. Compilation Time/Stage
        - Import nie jest wykonywany podczas kompilacji script.py — tylko zostaje przygotowany do wykonania.
          Python traktuje import module_A jak zwykłą instrukcję.
          W AST jest reprezentowana jako np. 'ast.Import'. W bytecode pojawi się instrukcja typu IMPORT_NAME.

 3. Runtime
       - Gdy interpreter napotyka instrukcję 'import module_A', to wtedy jest wykonywana pełna obsługa importu modułu module_A.
         Jej przebieg:
         Runtime(import flow 1) - Python sprawdza sys.modules czy dany moduł jest już załadowany
         (Nie jest.)
         Runtime(import flow 2) - Python szuka module_A.py w sys.path
         (Jeśli plik 'module_A.py' istnieje a .pyc jest nieaktualny lub brak.)

         Runtime(import flow 3) - Python wczytuje źródło 'module_A.py', sprawdza składnię kodu i parsuje go do AST,
         Runtime(import flow 4) - Następnie Python kompiluje kod do bytecode`u.

         Runtime(import flow 5) - Teraz Python:
                                     Tworzy obiekt modułu (types.ModuleType)
                                     Rejestruje go w sys.modules

         Runtime(import flow 6) - W końcu Python wykonuje bytecode w namespace modułu.
                                  To tak naprawdę uruchomienie wszystkiego, co nie jest ukryte w funkcji lub klasie.

                                  Krok po kroku:

                                  6a)
                                  Wykonywany jest cały tzw. kod na poziomie globalnym modułu
                                    definicje klas i funkcji
                                    przypisania zmiennych
                                    instrukcje warunkowe, pętle
                                    dowolny kod imperatywny
                                    blok if __name__ == "__main__"  jest ignorowany, nigdy warunek nie będzie spełniony

                                  6b)
                                  To działanie (6a) ma konkretne efekty strukturalne w Pythonie:
                                    Tworzy się przestrzeń nazw (namespace) modułu
                                    Wszystko, co zostanie zdefiniowane (funkcje, klasy, zmienne), trafia do mod.__dict__.
                                    To właśnie ta przestrzeń jest potem dostępna jako module_A.some_function.

                                    Tworzone są obiekty klas i funkcji
                                    Podczas wykonywania def i class tworzony jest odpowiedni obiekt typu function lub type.
                                    Każdy def to instancja function, a class to wywołanie metaklasy.

                                    Wszystkie efekty uboczne się wykonują
                                    Jeśli w module jest np. print("Uruchamiam się!"), to ten print się wykona.
                                    Jeśli jest połączenie z bazą danych — ono też może się wykonać (jeśli umieszczone globalnie).

                                    Importy zależne też są wykonywane
                                    Jeśli module_A importuje inne moduły (import module_B), to zaczyna się kaskada importów.


Other things: importlib.reload()
    - Python re-executes the module (skipping parsing/compiling if bytecode is cached and valid).
    - All top-level code runs again, which can reset state or redefine classes/functions.

import importlib
importlib.reload(module_A)</pre>
                <ul>
                    <li><a href="images/import_system_details_pl.png">[import system] Python Execution Model and 'Python Startup Stage'.</a></li>
                    <li><a href="images/import_system_MoreDetails_ParsingStage1_pl.png">[import system] More details, parsing stage 1.</a></li>
                    <li><a href="images/import_system_MoreDetails_ParsingStage2_pl.png">[import system] More details, parsing stage 2 and (ast).</a></li>
                    <li><a href="images/import_system__mainDotPy_file.png">[import system] '__main__.py' and runnable packages.</a></li>
                    <br>
                    <li><a href="images/import_system_AdvancedTechnics_LazyImports_optimization.png">[import system] Zaawansowane techniki importu, Lazy imports i optymalizacja importów (Python 3.7+)</a></li>
                </ul>
        <hr>
        <hr>
        <hr>
            <li>Why Python/CPython is so slow? Many reasons? One is that PVM interprets bytecode line by line - there are no native CPU instructions (like for example in JVM).</li>
            <li>Running object creation in infinite loop, but without assigning to reference. Memory consumption did not increase. Garbage collector doesn't show any symptoms of working behaviour. This is edge case when Python potentially ignored such object memory allocations. But spotted possible GC related Memory leak when running object creation in infinite loop, with constantly re-assigning reference (gc_objects = gc.get_objects()). Memory consumption increases. GC tracked objects increases.</li>
        <hr>
        <hr>
        <hr>
</ol>
<br>
<b style="background: #ADD8E6;">Python Call Stack / Python Frames:</b>
<br>
<br>
<ol start="18">
        <li>Cases when Python creates Frames objects? Function calls, importing modules, execution main script (__main__), execution classes call body. Also, eval/exec can cause additional Frames are created.</li>
        <br>
        <hr>
        <hr>
        <hr>

</ol>
<br>
<b style="background: #ADD8E6;">CLASSES:</b>
<br>
<br>
<ol start="19">
        <li>Weak references, unpopular Python feature (class __weakref__ attribute that does almost nothing. Weak references logic is managed by Python interpreter). Advanced projects with critically important memory management aspect (for example: help for Garbage Collector).</li>
        <br>
        <li>Python class level '__slots__' mechanism - it predefines possible instance attributes (there is no __dict__ on instance level). Many instance as performance optimization Use Case. Simulation showed 150-300 MB memory saving when 1 million objects are handled.</li>
        <br>
        <li>dir() - there is easy explanation why dir command does not return always all attributes. Simply, it calls __dir__ underneath and __dir__ can be implemented differently. And often it is. Python documentation says "The default dir() mechanism behaves differently with different types of objects, as it attempts to produce the most relevant, rather than complete ..."</li>
        <br>
        <li>When obj = object() then obj is instance of class (named object), but object is class and classes are instances of type metaclass (unless you use your own new metaclass). In Python everything inherits from object class apart from type metaclass that doesn't inherit from anything.</li>
        <br>
        <li>Python 3.7 introduced a concept known as "forward references," which allows us to use the class name as a string when defining type hints. Starting from Python 3.7, you can also use the from __future__ import annotations import, which automatically treats all annotations as forward references.</li>
        <br>
        <li>'__subclasshook__' - interesting feature that allows to dynamically deduct if subclass belong to base class (even without real inheritance).</li>
        <br>
        <li>What does mean that super technically can be called "proxy object"? What are details of functioning super?</li>
            <ul>
                <li>super only redirects lookup-calls to the correct parent class.</li>
                <li>For this super uses Descriptor protocol - it has own implementation of __get__.</li>
                <li>super handles creating temporary binding objects for instance and class methods (this binding is only relevant for the duration of the method call).</li>
            </ul>
        <br>
            <li>Bound methods. Base Concept for different type of functions in Class definitions. For example, @staticmethod decorator role is to revert/bypass this machinery.</li>
        <br>
        <li>What are details about class creation flow/protocol in Python? How can it be tuned?</li>
        <br>
        <li>What it is zero-cost metaclassing mechanism?</li>
 <pre class="code">
 - PEP 697, Python 3.12 introduces a zero-cost mechanism that optimizes the way metaclasses are determined.
</pre>

<li>Implementing metaclass __call__ method causes that this method is called during class instance creation (flow is changed).</li>
<br>

<li>The word about 'object' class - concretely instances - and when object() structure could be useful. object() doesnt have __dict__ and is immutable. (Sentinel, Locks)</li>



</ol>
<br>
<b style="background: #ADD8E6;">PROTOCOLS:</b>
<br>
<br>
<ol start="31">
        <li>Python as protocol oriented language. There is set of behaviours implemented as Protocols in Python, but to be Protocol oriented language? It is probably not enough.</li>

        <br>

        <li>[Descriptors protocol]: Python Descriptor object is class attribute self-defining way of accessing it in instance level scope (using: __get__, __set__, __delete__).</li>
        <ul>
            <li>Python is deeply equipped with Descriptors (fe: functions, methods, properties, class methods, static methods, super).</li>
            <li>Descriptors have effects when defined as class variables and when called from instance scope. When created in instances, they have no effect. But also descriptors logic is not triggered from classes scope.</li>
                <li>Python Descriptors Nature is by design being "properties" (they are "attached" to instances). Descriptors control instance attributes. Metaclasses control class attributes.</li>
            <ul>
                <li>The mechanism for descriptors is embedded in the __getattribute__() methods for object, type, and super(). There are nuances in terms of descriptor invocation logic in these implementations. For example, Instance lookup scans through a chain of namespaces giving data descriptors the highest priority, followed by instance variables, then non-data descriptors, then class variables, and lastly __getattr__() if it is provided.</li>
                <li>__set_name__ hook is called during class creation extends capability of descriptor objects.</li>
            </ul>
        </ul>
        <br>
        <br>

        <li>[Attribute lookup protocol]: Attribute lookup for Class, Instance, Super:</li>
<pre style="notion">

In high level it is such mechanism:
    try:
        [type, object, super].__getattribute__(...)
    except AttributeError:
        [type, object, super].__getattr__(...)

Potential modifiers:
 - Descriptors
 - Metaclasses
 - __slots__ functionality</pre>

Use cases:
    <table>
        <tbody>
        <td>
        <pre>
1. Instance objects
  - lookup for instance attribute
  - lookup for class attribute
  - object.__getattribute__ (def)</pre>
        </td>
        <td>
        <pre>
2. Class objects:
  - lookup for class attribute
  - type.__getattribute__ (def)</pre>
        </td>
        <td>
        <pre>

3. Super object executes lookup:
  - from Instance object for instance/class attribute
  - from Class object for instance/class attribute
  - by default super().__getattribute__ is taken
        </pre>
        </td>
        </tbody>
    </table>
</ol>

<br>
    <b style="background: #ADD8E6;">Functions Deep Dive:</b>
    <br>
    <br>

    <ol start="34">
        <li>Functions are objects, but not so-typical. What makes functions not typical objects?</li>
<pre>

1. Functions local scope is built different:
 - Function local scope exists in runtime and is built based on temporarily created Stack Frame,
 - this Frame leverages the data from funct.__code__ for creating local scope
 - If we have look into temporarily created Frame (named F) then:
    - we can check that: F.f_locals is locals() => gives True
    - so Python Frame Stack is used to build Function local scope
2. Functions have a __code__ object storing function bytecode.
3. Functions have a __dict__ used bit different, only for storing attributes (what is kind of specific functions behaviour).
4. Functions support closure pattern (__closure__ remembers variables from outer scope). Fundamental mechanism for predictability.
5. Every function written in Python is Non-Data Descriptor (when C based not).</pre>

<br>
    <li>Tricky edge case for imports in Class when code is C-based. How creating Bound Method works here?</li>
<pre>
class A:
    from json import dumps as g # written in Python and defines __get__ (however there can be 2 implementations: Python/C)
    from itertools import repeat as h   # it is callable class written in C, doesn't define __get__

Notes:
 * During Runtime when 'class A' is created, class body-content is being executed line by line (like function).
 * A.g("xx")   - ok
 * A.h("xx")   - ok
 * A().g("xx") - TypeError: dumps() takes 1 positional argument but 2 were given
 * A().h("xx") - ok
 * @classmethod impact
</pre>

</ol>



<br>

<b style="background: #ADD8E6;">Testing things:</b>
<br>
<ol start="36">
        <li>Mock and Stub what is the difference? Other test doubles: Dummy, Fake, Spy</li>
<pre>
Mock:
  - It should be used for verifying interactions, ensuring the correct methods are called with the expected parameters.
  - Mocks can be configured to throw exceptions, return different values for different calls, and so on (can be complex).
Stub:
  - this test double focuses on providing data (predefined responses) to control the test environment
  - often used to simulate the behavior of external services or components (isolating dependencies)

    => Both stubs and mocks help isolate the code under test by replacing external dependencies with controlled behavior.

Dummy
 - the simplest form of a test double. It is an object that is passed around but is never actually used (serves as a placeholder)
 - Dummies are used when an argument is required by the code being tested, but it’s not actually used during the test.
Fake
 - test double that has working implementations but is simplified or not as performant as the real system
 - Fakes are used when a real system might be too complex or slow, but you still want some kind of working implementation
Spy
 - more advanced type of test double that not only helps verify interactions (like a mock) but also records the calls made to it
Fixture
 - In the context of testing, fixtures can be considered as part of the broader test double or test setup family.
 - Any setup or configuration required to run your tests. Ensuring that the necessary context is available for the tests to execute.
 - Typically includes the creation of test data, that can be even related to setting up a connection to a database or web server.
 - Fixtures are about test setup and teardown — while test doubles isolate/control behavior of components within that environment.

Test Doubles (Mocks, Stubs, Fakes, etc.):
 - Used to replace or simulate specific parts of a system, like dependencies or external services, that your code interacts with.
 - They help isolate/control the code under test and allow you to control behaviors and verify interactions.

</pre>
        <li>Mocking frameworks: unittest.mock, when to use MagicMock and when Mock?.</li>
<pre>
Use Mock when:
 - You only need to mock regular methods or attributes that are not related to magic methods (i.e., methods you define yourself).
 - You don't need support for special behavior like indexing, iterating, or arithmetic operations.

Use MagicMock when:
 - You need to mock magic methods (__getitem__, __setitem__, __call__, __iter__, etc.) or objects involved in such operations.
 - You deal with objects that emulate builtin containers like lists, or objects that need to support special methods in your tests.</pre>
        <br>
        <li>Mocking vs patching? What is difference?</li>
        <br>
        </ol>

<b style="background: #ADD8E6;">Concurrency things:</b>
<br>
<ol start="39">
        <li>When 'race condition' situation happens?</li>
<pre>
 - multiple threads or processes access shared data and at least one modifies it, but the access is not properly synchronized.
</pre>
        <li>What means that operations are 'thread-safe'?</li>
<pre>
 - ensuring that only one thread can modify 'specific shared resource' at a time.
</pre>


</ol>

<b style="background: #ADD8E6;">TODO:</b>
<br>
<pre>
 - fastapi, pydantic
 - Django simple personal website
 - Bigger project ideas
</pre>

</div>
</div>
</div>
</div>



<br>

<div class="row">
    <div class="col-md-8">
            <div class="card mb-4 box-shadow">
                <div class="card-body">
    <a class="main-a"  href="https://docs.python.org/3/tutorial/interpreter.html">2. Using the Python Interpreter</a>

    <ol>
        <li>Invoking the Interpreter</li>
            <div class="shell">$ whereis python3 / interactive Mode (run python3)</div>
            <div class="shell">$ python3 -c 'from time import sleep;sleep(2);print("I have slept 2 seconds, wow.")'</div>
        <li>Argument Passing:</li>
        <ul>
            <li>sys.argv</li>
            <li>argparse module</li>
        </ul>
        <li>sys.stdin:</li>
        <ul>
            <li><div class="shell">$ cat sys_module/short_text_file.txt | python3 sys_module/standard_input.py</div></li>
            <a href="https://github.com/DanielPalacz/py-notes/blob/main/sys_module/standard_input.py" target="_blank">standard_input.py</a>
            <li><pre><div class="shell">python3 sys_module/standard_input.py &lt;&lt;EOF
> 123
> abc
> 233342
>EOF</div></pre></li>
        </ul>
        <li>Source Code Encoding: by default UTF-8</li>
        <ul>
            <li>To declare an encoding other than the default one, a special comment line should be added as the first line of the file. Example:</li>
            <div class="code"># -*- coding: cp1252 -*-</div>
            <li>One exception to the first line rule is when the source code starts with a <b>UNIX “shebang” line</b>.</li>
            <pre><div class="code">#!/usr/bin/env python3
# -*- coding: cp1252 -*-</div></pre
        </ul>
    </ol>
</div>
</div>
</div>
</div>



<div class="row">
    <div class="col-md-8">
            <div class="card mb-4 box-shadow">
                <div class="card-body">
                <a class="main-a" href="https://docs.python.org/3/tutorial/introduction.html">3. An Informal Introduction to Python</a>

    <ul>
        <li>floor div (//) returns INT</li>
        <li>raw string <span class="code" style="font-weight: bold;">r"..."</span> => <span></span><span><a href="https://github.com/DanielPalacz/py-notes/blob/main/general/raw_string.py" target="_blank">raw_string.py</a></span></li>
        <li>revert: s = '123456789' =><span class="code" style="font-weight: bold;">s[-1::-1]</span></li>
        <li><span class="code">print(a, end='X', sep=';')</span></li>
        <li class="notion">iterable object</li>
        <div class="notion-explanation">An iterable is any Python object capable of returning its members one at a time, permitting it to be iterated over in a for-loop.</div>
        <li class="notion">sequence object</li>
        <div class="notion-explanation">The iterable objects implementing 2 specific methods: '__getitem__()', '__len__()'. So sequences can be Indexed/Sliced.</div>
        <li class="notion">immutable object</li>
        <div class="notion-explanation">Values of the object cant be changed (First order values in terms of container like tuple).</div>
        <div class="notion-explanation">Examples of python immutable data structures: int, float, decimal, bool, string, byte, range, tuple</div>
        <li class="notion">mutable object</li>
        <div class="notion-explanation">Values of the object can be changed after the object creation.</div>
        <div class="notion-explanation">Examples of python mutable data structures: list, dict, set, custom editable classes</div>
    </ul>
</div>
</div>
</div>
</div>




<div class="row">
    <div class="col-md-8">
            <div class="card mb-4 box-shadow">
                <div class="card-body">
                <a class="main-a" href="https://docs.python.org/3/tutorial/controlflow.html">4. More Control Flow Tools</a>

    <ul>
        <li>Python loops:</li>
        <ul>
            <li class="code">if-elif-else, for-else, while-else</li>
        </ul>
    </ul>

    <ul>
        <li>Loops related keywords:</li>
        <ul>
            <li class="code">break, continue, pass</li>
        </ul>

    </ul>
    <ul>
        <li>match statement (added in 3.10):</li>
        <pre><div class="code">def http_error(status):
    match status:
        case 400:
            return "Bad request"
        case 404:
            return "Not found"
        case 418:
            return "I'm a teapot"
        case _:
            return "Something's wrong with the internet"</div></pre>
        <li>Defining Functions:</li>
        <div class="code">def funct(pos_arg1, pos_arg2=7, /, some_arg3, some_arg4=2, *, k_arg1, k_arg2="dwa")</div>
        <div class="code">def funct(argx, argy, argz, *args, **kwargs):</div>
        <div>default value: the default value is evaluated only once - during parsing stage</div>
        <div class="notion">keyword '*'</div>
        <ul>
            <li class="notion-explanation">arguments after the keyword have to be keyword-like arguments</li>
        </ul>
        <div class="notion">keyword '/'</div>
        <ul>
            <li class="notion-explanation">arguments before the keyword have to be positional-like arguments</li>
        </ul>
        <li>Annotations:</li>
         <ul>
            <li class="code">funct(a: str, number: int, dogs: tuple[str]) -> list[str]:</li>
            <div class="code">funct.__annotations__</div>
            <div class="code">
                {'a': &lt;class &quot;str&quot;&gt;, 'number': &lt;class &quot;int&quot;&gt;, 'dogs': tuple[str], 'return': list[str]}
            </div>
        </ul>
        <li>Docsrings<span class="code"> (object.__doc__):</span></li>
        <div class="notion-explanation">ALL modules should normally have docstrings, and ALL functions and classes exported by a module should also have docstrings</div>
        <div class="notion-explanation">Public methods (including the __init__ constructor) should also have docstrings.</div>
        <div class="notion-explanation">A package may be documented in the module docstring of the __init__.py file in the package directory.</div>
        <a href="https://www.python.org/dev/peps/pep-0257/" target="_blank">PEP-0257</a>
        <span>, </span>
        <a href="https://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_google.html" target="_blank">Google Style Python Docstrings,</a>
    </ul>
</div>
</div>
</div>
</div>



<div class="row">
    <div class="col-md-8">
        <div class="card mb-4 box-shadow">
            <div class="card-body">
                <a class="main-a" href="https://docs.python.org/3/tutorial/datastructures.html">5. Data Structures (basic)</a>

            </div>
</div>
</div>
</div>



<div class="row">
    <div class="col-md-8">
        <div class="card mb-4 box-shadow">
            <div class="card-body">
                <a class="main-a" href="https://docs.python.org/3/tutorial/modules.html">6. Modules</a>
                <ul>
                    <li>Python module search algorithm:</li>
                    <ol>
                        <li class="notion-explanation">built-in modules</li>
                        <li class="notion-explanation">sys.path directories</li>
                        <li class="notion-explanation">PYTHONPATH env directory</li>
                        <li class="notion-explanation">Python installation directories</li>
                    </ol>

                    <li class="code">__all__</li>
                    <ul>
                        <li class="code">from package import *</li>
                        <li class="notion-explanation">the list of module names when 'from package import *' is encountered.</li>
                    </ul>

                    <li class="shell">python -B [python_file]</li>
                    <ul>
                        <li class="notion-explanation">will not write compiled py files like: __pycache__/modx.pyc</li>
                    </ul>
                    <li>Namespaces in Python:</li>
                    <div class="notion-explanation">namespace is the structure used to organize the symbolic names assigned to objects in a Python program</div>
                    <div>LEGB rule (can be changed by: global/nonlocal keywords)</div>
                    <ul>
                        <li>LEG are implemented as dictionaries / B as module</li>
                        <li>How to see LEGB contents? LE: locals(), G: globals(), dir() and dir(imported_module), B: dir(__builtins__)</li>
                        <li>namespaces creation lifetime:</li>
                    <ul>
                        <li>B: created when the Python interpreter starts up, and is never deleted. It lives as __builtins__</li>
                        <li>G (also for module): is created when the module definition is read in; normally, module namespaces also last until the interpreter quits</li>
                        <li>LE: is created when the function is called, and deleted when the function returns or raises an exception that is not handled within the function.</li>
                    </ul>
                    </ul>
                </ul>

            </div>
        </div>
    </div>
</div>





<div class="row">
    <div class="col-md-8">
        <div class="card mb-4 box-shadow">
            <div class="card-body">
                <a class="main-a" href="https://docs.python.org/3/tutorial/inputoutput.html">7. Input and Output</a>
                <ul>
                    <li class="todo">TODO</li>
                </ul>

            </div>
</div>
</div>
</div>


<div class="row">
    <div class="col-md-8">
        <div class="card mb-4 box-shadow">
            <div class="card-body">
                <a class="main-a" href="https://docs.python.org/3/tutorial/errors.html">8. Errors and Exceptions</a>
                <ul>
                    <li>try / except / else / finally:</li>
<pre class="code">
try:
    ~ code to execute
except Error1:
    ~ code to handle Error1
except (Error2, Error3, Error4):
    ~ code to handle Errors2-4
except Error5 as e5:
    ~ code to handle Error5
    ~ print(e5.args) -> printing Exception arguments
except:
    ~ code to handle unexpected errors
else:
    ~ code to be executed if the try clause does not raise an exception
finally:
    ~ code to be executed in very end
    ~ often for cleanup activities
    ~ ... print("Unexpected error:", sys.exc_info()[0])
    ~ ... raise -> we can even read type of exception and handle it</pre>

<li class="code">raise ExceptionName</li>
<br>
<li>builtin exceptions, there are (at least) two distinguishable kinds of errors: syntax errors and exceptions:</li>
<ul>
    <li>NameError, OSError, KeyboardInterrupt, SyntaxError (Parsing error)</li>
    <li>ImportError, IndexError, KeyError, RuntimeError</li>
    <li>TypeError, AssertionError, ValueError, ZeroDivisionError</li>
</ul>
<br>
<li>If you need to determine whether an exception was raised but don’t intend to handle it:</li>
<pre class="code">
try:
  raise NameError('HiThere')
except NameError:
  print('An exception flew by!')
  raise
</pre>

<li class="code">raise NewException(..) from OriginalException(..)</li>
</ul>

</div>
</div>
</div>
</div>



<div class="row">
    <div class="col-md-8">
        <div class="card mb-4 box-shadow">
            <div class="card-body">
                <a class="main-a" href="https://docs.python.org/3/tutorial/classes.html">9. Classes</a>
                <ul>
                    <br>
                    <u><b>Class object creation flow (without __slots__ impact):</b></u>
                    <ul>
                    <br>
                    <li>When Interpreter sees 'class' then calling __build_class__(func, name, *bases, **kwargs). Class body is treated as special-function.</li>
                    <ul>
                        <li>If metaclass has defined __prepare__ (must return a mapping) then it is called else empty dict is passed further as namespace.</li>
                    </ul>
                    <br>
                    <li>Class body is executed and a new namespace is created and used as the local scope.</li>
                    <ul>
                        <li>If Class body contains super/__class__ calls then Python creates a cell variable (__classcell__) with __class__ object.</li>
                         <ul>
                            <li>This ensures that methods inside the class can access __class__, even before the class is fully defined.</li>
                        </ul>
                    <br>
                    </ul>
                    <li>Calling [metaclass/type].__new__(name, bases, namespace)</li>
                    <ul>
                        <li>custom metaclass can set here own logic like creating attributes, methods (by default type metaclass)</li>
                        <li>If class have descriptor methods then '__set_name__(owner, name)' is called (if __set_name__ is defined).</li>
                    </ul>
                    <br>
                    <li>Calling type.__init__(self, name, bases, namespace).</li>
                    <ul>
                        <li>For subclasses: type.__init__ calls '__init_subclass__'</li>
                    </ul>
                    </ul>
                    <br>
<br>
<li>
<div class="notion"><a style="font-size:20px;" href="https://docs.python.org/3/tutorial/classes.html#inheritance">Inheritance</a></div>
<div class="code"> - isinstance(obj, int)<br> - issubclass(float, int)</div>
</li>
<br>
<li>
<a style="font-size:20px;" href="https://realpython.com/python-super/">super()</a>
    <div class="notion-explanation"> - technically, it is called "proxy object"</div>
    <div class="notion-explanation"> - allows us to avoid using the base class name explicitly</div>
    <div class="notion-explanation"> - working with Multiple Inheritance</div>
</li>

<br>
<li>
<a style="font-size:20px;" href="https://docs.python.org/3/tutorial/classes.html#multiple-inheritance">Multiple Inheritance</a>
    <div class="notion-explanation"> - class DerivedClass(Base1, Base2, Base3)</div>
    <div class="notion-explanation"> - Diamond problem solved by: DerivedClass.<b>__mro__</b></div>
</li>
<br>
<li>
<a style="font-size:20px;" href="https://docs.python.org/3/tutorial/classes.html#private-variables">Privateness</a>
    <div class="notion-explanation"> - “Classic Private” resources accessed only from inside an object don’t exist in Python.</div>
    <div class="notion-explanation">  - Everything about privacy in Python is "Convention":</div>
    <div class="notion-explanation"> - <b>"Pseudo-privacy resource"</b> starts from __ like: __siup are and not accessible directly.</div>
    <ul>
        <div class="notion-explanation"> - but due to <em>Name Mangling</em> the given resource will be available under "_ClassX__siup"</div>
    </ul>

    <div class="notion-explanation"> - <b>"Protected resource"</b> starts from _ like: '_bubu'</div>
</li>

<hr>
<br>
<li style="font-weight: bold; font-size:24px;">Iterators:</li>
<div class="notion-explanation">An iterator is a class that implements two special methods: __iter__() and __next__().</div>
<ul>
    <li class="notion-explanation">__iter__(): This method is called when an iterator is required for an object. It should return the iterator object itself.</li>
    <li class="notion-explanation">___next__(): This method should return the next value in the iteration sequence. When there are no more items to return, it should raise the StopIteration exception.</li>
</ul>
<br>
<pre class="code">
class SquareIterator:
    def __init__(self, limit):
        self.limit = limit
        self.current = 0

    def __iter__(self):
        return self  # The iterator object itself

    def __next__(self):
        if self.current < self.limit:
            result = self.current ** 2
            self.current += 1
            return result
        else:
            raise StopIteration  # No more items to iterate over

# Using the custom iterator
square_iter = SquareIterator(5)  # Squares from 0^2 to 4^2

for square in square_iter:
    print(square)

square_iter2 = SquareIterator(3)  # Squares from 0^2 to 3^2 and raises StopIteration
print(next(square_iter2))
print(next(square_iter2))
print(next(square_iter2))
print(next(square_iter2))
</pre>
<pre class="shell">
0
1
4
9
16
0
1
4
Traceback (most recent call last):
  File "PATH/iterators.py", line 22, in <module>
    print(next(square_iter2))
  File "PATH/iterators.py", line 15, in __next__
    raise StopIteration  # No more items to iterate over
StopIteration
</pre>
<a class="yellow-this" style="font-size:20px;" href="https://github.com/DanielPalacz/py-notes/blob/main/general/iterators.py">iterator class example</a>
<hr>
<br>


<li style="font-weight: bold; font-size:24px;">Generators:</li>
<div class="notion-explanation">Generators are a functions which return a generator-iterator objects.</div>
<div class="notion-explanation">Generator-iterator objects follow Iterator protocol, because of implementing __iter__ and __next__ methods.</div>
<div class="notion-explanation">Anything that can be done with generators can also be done with class-based iterators.</div>
<div class="notion-explanation">What makes generators so compact is that the __iter__() and __next__() methods are created automatically.</div>
<div class="notion-explanation">In addition to automatic method creation and saving program state, when generators terminate, they automatically raise StopIteration.</div>
<div class="notion-explanation">These features make it easy to create iterators with no more effort than writing a regular function.</div>
<br>
<div>Simple generator:</div>
<pre class="code">

def reverse(data):
    for index in range(len(data)-1, -1, -1):
        yield data[index]

for char in reverse('golf'):
    print(char)
</pre>
<pre class="shell">
f
l
o
g
</pre>
<div style="text-decoration: underline;">Great example of usage generators - processing big file:</div>
<pre class="code">
def read_large_file(file_path):
    with open(file_path) as file:
        for line in file:
            yield line.strip()

for line in read_large_file("big_file.txt"):
    print(line)  # Processing line without loading full file to memory.
</pre>

<div style="text-decoration: underline;">Generators advanced features:</div>
<ul>
    <li>sending data to generators: <span class="code">send(value)</span></li>
    <div class="notion-explanation">Send starts generator and sends 'value' to yield expression.</div>
    <div class="notion-explanation">First generator call has to be via next or send(None).</div>
    <li>sending exception to generators: <span class="code">throw(Exception, 'Message')</span></li>
    <li>closing generators by: <span class="code">close()</span></li>
    <li>delegating to other generators by: <span class="code">yield from</span></li>
    <li>generator expressions:</li>
<pre class="code">
gen = (x**2 for x in range(5))
print(next(gen))  # Output: 0
print(next(gen))  # Output: 1
</pre>
</ul>
</ul>
<hr>

</div>
</div>
</div>
</div>



<hr>
<br>


<div class="row">
    <div class="col-md-8">
        <div class="card mb-4 box-shadow">
            <div class="card-body">
                <a class="main-a" href="https://docs.python.org/3/tutorial/stdlib.html">10. Brief Tour of the Standard Library</a>
                <ul>
                    <li><a href="https://docs.python.org/3/tutorial/stdlib.html#operating-system-interface">10.1. Operating System Interface</a></li>
                    <div>os, shutil modules</div>
                    <li><a href="https://docs.python.org/3/tutorial/stdlib.html#file-wildcards">10.2. File Wildcards</a></li>
                    <div>glob module</div>
                    <li><a href="https://docs.python.org/3/tutorial/stdlib.html#command-line-arguments">10.3. Command Line Arguments</a></li>
                    <div>sys.argv</div>
                    <div>argparse module</div>
                    <a class="yellow-this" href="https://github.com/DanielPalacz/py-notes/blob/main/general/argparse_basic.py">example</a>
                    <li><a href="https://docs.python.org/3/tutorial/stdlib.html#error-output-redirection-and-program-termination">10.4. Error Output Redirection and Program Termination</a></li>
                    <div class="code">sys.stderr.write('Warning, log file not found starting a new one\n')</div>
                    <li><a href="https://docs.python.org/3/tutorial/stdlib.html#string-pattern-matching">10.5. String Pattern Matching</a></li>
    <pre class="code">
    import re
    re.findall(r'\bf[a-z]*', 'which foot or hand fell fastest')
    re.sub(r'(\b[a-z]+) \1', r'\1', 'cat in the the hat'</pre>

    <pre class="shell">
    ['foot', 'fell', 'fastest']
    'cat in the hat'</pre>

                    <li><a href="https://docs.python.org/3/tutorial/stdlib.html#mathematics">10.6. Mathematics</a></li>
                    <div>modules: math, random, statistics, secrets</div>
                    <li><a href="https://docs.python.org/3/tutorial/stdlib.html#internet-access">10.7. Internet Access</a></li>
                    <div>modules: urllib.request, smtplib</div>
                    <li><a href="https://docs.python.org/3/tutorial/stdlib.html#dates-and-times">10.8. Dates and Times</a></li>
                    <div>modules: datetime, time</div>
                    <li><a href="https://docs.python.org/3/tutorial/stdlib.html#data-compression">10.9. Data Compression</a></li>
                    <div>modules: zlib, bx2, lzma, zipfile, tarfile</div>
                    <li><a href="https://docs.python.org/3/tutorial/stdlib.html#performance-measurement">10.10. Performance Measurement</a></li>
                    <div>modules: timeit, profile, pstats</div>
                    <li><a href="https://docs.python.org/3/tutorial/stdlib.html#quality-control">10.11. Quality Control</a></li>
                    <div>modules doctests:</div>
    <pre class="code">
    def average(values):
        """Computes the arithmetic mean of a list of numbers.

        >>> print(average([20, 30, 70]))
        40.0
        """
        return sum(values) / len(values)
    import doctest
    doctest.testmod()   # automatically validate the embedded tests</pre>
                    <div>module unittest:</div>
    <pre class="code">
    import unittest

    class TestStatisticalFunctions(unittest.TestCase):
        def test_average(self):
            self.assertEqual(average([20, 30, 70]), 40.0)
            self.assertEqual(round(average([1, 5, 7]), 1), 4.3)
            with self.assertRaises(ZeroDivisionError):
                average([])
            with self.assertRaises(TypeError):
                average(20, 30, 70)

    unittest.main()  # Calling from the command line invokes all tests</pre>
                    <li><a href="https://docs.python.org/3/tutorial/stdlib.html#batteries-included">10.12. Batteries Included</a></li>
                    <div>Python has a “batteries included” philosophy. This is best seen through the sophisticated and robust capabilities of its larger packages. For example:</div>
                <ul>
                    <li>The <span class="code">xmlrpc.client and xmlrpc.server</span> modules make implementing remote procedure calls into an almost trivial task.</li>
                    <li>email, json, csv, sqlite3 modules</li>
                    <li>XML processing is supported by the xml.etree.ElementTree, xml.dom and xml.sax packages</li>
                    <li>Internationalization is supported by a number of modules including gettext, locale, and the codecs package.</li>
                </ul>
                </ul>

            </div>
</div>
</div>
</div>




<div class="row">
    <div class="col-md-8">
        <div class="card mb-4 box-shadow">
            <div class="card-body">
                <a class="main-a" href="https://docs.python.org/3/tutorial/stdlib2.html">11. Brief Tour of the Standard Library — Part II</a>
                <ul>
                    <li><a href="https://docs.python.org/3/tutorial/stdlib2.html#output-formatting">11.1. Output Formatting</a></li>
                    <div>reprlib, pprint, textwrap, locale</div>
                    <li><a href="https://docs.python.org/3/tutorial/stdlib2.html#templating">11.2. Templating</a></li>
                    <div>string.Template</div>
                    <li><a href="https://docs.python.org/3/tutorial/stdlib2.html#working-with-binary-data-record-layouts">11.3. Working with Binary Data Record Layouts</a></li>
                    <div>struct pack and unpack functions</div>
                    <li><a href="https://docs.python.org/3/tutorial/stdlib2.html#multi-threading">11.4. Multi-threading</a></li>
                    <div>threading module</div>
                    <div class="notion-explanation">CPython implementation detail: In CPython, due to the Global Interpreter Lock, only one thread can execute Python code at once (even though certain performance-oriented libraries might overcome this limitation). If you want your application to make better use of the computational resources of multi-core machines, you are advised to use multiprocessing or concurrent.futures.ProcessPoolExecutor. However, threading is still an appropriate model if you want to run multiple I/O-bound tasks simultaneously.</div>
                    <a href="https://github.com/DanielPalacz/py-notes/tree/main/threading_examples" target="_blank">threading examples</a>
                </ul>

            </div>
</div>
</div>
</div>




<div class="row">
    <div class="col-md-8">
        <div class="card mb-4 box-shadow">
            <div class="card-body">
                <h4 style="font-weight: bold;">Unicode and UTF-8 - default in Python</h4>
                <ul>
                    <li>Unicode - text/symbol representation standard (also emoji and special codes)</li>
                     <ul>
                        <li>also defined as symbol coding representation system</li>
                    </ul>
                    <li>UTF-8 - symbol encoding (to bytes) system</li>
                    <ul>
                        <li>every ASCII text is UTF-8 text</li>
                        <li>UTF-8 is default for JSON, XML</li>
                    </ul>
                    <li>ASCII - symbol encoding (to bytes) system</li>
                </ul>
            </div>
        </div>
    </div>
</div>





<div class="row">
    <div class="col-10">
    <br>
    <div class="button-custom mb-4">
            <a href="" class="btn btn-dark btn-lg mt-1 button-link-custom" style="font-weight: bold; text-align: center;">Other Python notes</a>
    </div>
</div>
</div>
<br>




<div class="row">
    <div class="col-md-8">
        <div class="card mb-4 box-shadow">
            <div class="card-body">
                <h4 style="font-weight: bold;">Python interpreter, it is python-program-responsible for:</h4>
                <ul>
                    <li>Python source code parsing</li>
                    <li>Python source code compiling to bytecode</li>
                    <li>Python bytecode execution.</li>
                </ul>
                <br>
                <h2 style="font-weight: bold;text-decoration: underline;">Python execution model:</h2>
                <br>
                <b><div>Parsing stage:</div></b>
                <div> - the goal is to create specific, custom AST structure</div>
                <div> - Python interpreter components: Tokenizer / Lexer, Parser</div>
                <br>
                <ul>
                    <li>The first step of a parsing process is splitting up 'python code' into a list of pieces usually called tokens. (done by tokenize/tokenizer.c module).</li>
                    <li>The raw list of tokens is input of a Parser component that transforms them to build an Abstract Syntax Tree (based on Python grammar).</li>
                    <li>An AST is a collection of nodes which are linked together based on the grammar of the Python language.</li>
                    <li>AST is a later input for a compiling process when a lower level form of instructions called bytecode is generated.</li>
                </ul>
                <br>
                <b><div>Compilation stage:</div></b>
                <div> - the goal is to transform AST structure to Python bytecode</div>
                <div> - Python interpreter components: Symtable, Compiler (AST → Bytecode), Bytecode emitter, Code objects</div>
                <br>
                <ul>
                    <li>During compilation, certain constant expressions, such as default argument values, are evaluated.</li>
                    <li>This is where the compile() function works – it transforms the AST into bytecode. Python objects such as functions or classes are created at runtime, but their structure is defined during compilation.</li>
                </ul>

                <br>
                <b><div>Execution stage (runtime):</div></b>
                <ul>
                    <li>Python interpreter components: Python Virtual Machine (PVM), Frame Stack / Call Stack, Namespaces: Builtins, Globals, Locals.</li>
                    <li>PVM — conceptual layer realized by function _PyEval_EvalFrameDefault() in ceval.c (Bytecode interpreter is main part).</li>
                </ul><br>
<pre>
Runtime is the phase in Python Execution model when:
    - PVM/PVM Interpreter interprets/executes bytecode (instructions saved in stack frame)
        - knowing that PVM / other C-Function are compiled code = machine code (inside python program) that understands bytecode
        - then Python bytecode is read and executed "instruction after instruction" by PVM (compiled CPython machine code)
          (*** important to see that Python source code is never translated to CPU machine code - at least in CPython)
    + mentioned stack frame mechanism functionalities are performed
    + other mechanisms required functions are executed: GC, exception handling, import system
</pre>

<br>
<hr>
<hr>
<pre>

1. Komponenty fazy parsowania (kod źródłowy Pythona -> AST)
 - Tokenizer / Lexer, Parser


2. Komponenty kompilacji (AST → Bytecode)
    [AST]
       ↓
    [symtable.c] → tworzy mapę nazw
       ↓
    [compile.c] → przekształca AST do bytecode
       ↓
    [codeobject.c] → tworzy finalny PyCodeObject


Bytecode w CPythonie to:
 - zestaw instrukcji wirtualnej maszyny Pythona (PVM) [nie są kodem maszynowym CPU, więc nie są bezpośrednio wykonywane przez CPU]
 - lecz są instrukcjami rozumianymi przez interpreter PVM (czyli część softwarej maszyny PVM).


3. Runtime (Execution stage)
        ┌────────────────────────┐
        │                        │
        │   Python VM (ceval.c)  │ ← główny silnik wykonania
        │     ↓ eval loop        │
        │                        │
        └────────┬───────────────┘
                 │
                 │

    PVM w CPythonie to funkcja _PyEval_EvalFrameDefault() z pliku ceval.c,
     - jej zadaniem jest analiza bytecode krok po kroku, realizując go przez funkcje w C.
     - jej podstawową częścią jest interpreter bytecode'u Pythona.

                 │
                 │
                 │
        ┌────────▼──────────────┐
        │   Call Stack / Frames │ ← wykonanie funkcji, zakresy zmiennych
        └────────┬──────────────┘
                 │
     ┌───────────▼─────────────┐
     │ Memory Mgmt + GC        │ ← alokacja, refcount, GC
     └───────────┬─────────────┘
                 │
        ┌────────▼─────────────┐
        │ Namespaces & Builtins│ ← globals, locals, __builtins__
        └──────────────────────┘



</pre>

            </div>
        </div>
    </div>
</div>

<div class="row">
    <div class="col-md-8">
        <div class="card mb-4 box-shadow" style="background-color: pink;">
            <div class="card-body">
                <h4 style="font-weight: bold;">Computational complexity of algorithms:</h4>
                <ul>
                    <li>What kind of complexity? time performance / memory performance</li>
                    <a href="https://www.samouczekprogramisty.pl/podstawy-zlozonosci-obliczeniowej/">estimation function basics 1</a>
                    <br>
                    <a href="https://pl.typeofweb.com/zlozonosc-obliczeniowa-czasowa-pamieciowa-algorytmow">estimation function basics 2</a>

                </ul>
            </div>
        </div>
    </div>
</div>
<br>




<div class="row">
    <div class="col-md-9">
        <div class="card mb-4 box-shadow">
            <div class="card-body">
                <a class="main-a" href="https://code.tutsplus.com/tutorials/understand-how-much-memory-your-python-objects-use--cms-25609">Measuring the Memory Usage of Python Objects</a>
                <div>sys module provides the getsizeof() function calculating the actual memory usage for Python objects:</div>

            <div class="col">
                <ul>
                    <li>int</li>
                    <div class="code">sys.getsizeof(5)</div>
                    <div class="shell">28</div>
                    <li>float</li>
                    <div class="code">sys.getsizeof(5.3)</div>
                    <div class="shell">24</div>
                    <li>Decimal</li>
                    <div class="code">from decimal import Decimal</div>
                    <div class="code">sys.getsizeof(Decimal(5.3))</div>
                    <div class="shell">104</div>
                    <li>Python strings:</li>
                    <div class="code">sys.getsizeof('')</div>
                    <div class="shell">49</div>
                    <div class="code">sys.getsizeof('1')</div>
                    <div class="shell">50</div>
                    <div class="code">sys.getsizeof('1234')</div>
                    <div class="shell">53</div>
                    <div class="code">sys.getsizeof(u'1234')</div>
                    <div class="shell">53</div>
                    <li>Bytes:</li>
                    <div class="code">sys.getsizeof(bytes())</div>
                    <div class="shell">33</div>
                    <div class="code">sys.getsizeof(bytes(1))</div>
                    <div class="shell">34</div>
                    <li>Boolean values and None:</li>
                    <div class="code">sys.getsizeof(False)</div>
                    <div class="shell">24</div>
                    <div class="code">sys.getsizeof(True)</div>
                    <div class="shell">28</div>
                    <div class="code">sys.getsizeof(None)</div>
                    <div class="shell">16</div>
                </ul>
            </div>
                <div class="col">
                    <ul>
                    <li>Python lists:</li>
                    <div class="code">sys.getsizeof([])</div>
                    <div class="shell">56</div>
                    <div class="code">sys.getsizeof([1])</div>
                    <div class="shell">64</div>
                    <div class="code">sys.getsizeof([1,2])</div>
                    <div class="shell">72</div>
                    <div class="code">sys.getsizeof(["long string"])</div>
                    <div class="shell">64</div>
                    <li>Python tuples:</li>
                    <div class="code">sys.getsizeof(tuple())</div>
                    <div class="shell">40</div>
                    <div class="code">sys.getsizeof((1,))</div>
                    <div class="shell">48</div>
                    <div class="code">sys.getsizeof((1,2))</div>
                    <div class="shell">56</div>
                    <li>Python sets:</li>
                    <div class="code">sys.getsizeof(set())</div>
                    <div class="code">sys.getsizeof((1,))</div>
                    <div class="code">sys.getsizeof((1,2))</div>
                    <div class="shell">216</div>
                    <li>Python dictionaries:</li>
                    <div class="code">sys.getsizeof(dict())</div>
                    <div class="shell">216</div>
                    <div class="code">sys.getsizeof({"a": 1})</div>
                    <div class="code">sys.getsizeof(dict(a=1, b=2, c=3))</div>
                    <div class="shell">232</div>
                    </ul>
                </div>

      <p>CPython uses a lot of memory for its objects and because of this it uses various tricks and optimizations for memory management. By keeping track of your object’s memory usage and being aware of the memory management model, you can significantly reduce the memory footprint of your program.</p>
      <br>
      <h4>"being aware of the memory management model" - but what does it mean?</h4>
<pre>
Being aware of the memory management model is to know how Python uses memory : ) But not only.

In Linux it proceeds to understanding below notions / aspects:
    - all resources are eventually provided by kernel
    - virtual memory and other memory management functions
    - multithreading and multiprocessing
    - Call Stack in Python, Heap memory in Python / processor stack

    - OS level memory optimizations - like using processor cache memory for often used objects:
    - what are other processor / OS memory optimizations technics?
        - Paging and Swapping, Lazy Allocation, Transparent Huge Pages, Memory Overcommit
        - Copy-on-Write (CoW) - kiedy proces tworzy kopię (np. fork), Linux stosuje Copy-on-Write:
            - Pamięć współdzielona między procesami nie jest kopiowana od razu.
        - Kernel Same-page Merging (KSM), NUMA (Non-Uniform Memory Access), Asynchronous I/O i Direct Memory Access (DMA)
        - Reclaiming Memory (odzyskiwanie pamięci), HugeTLB (Huge Translation Lookaside Buffer),
        - Pamięć mapowana na pliki (Memory-Mapped Files), Linux pozwala na mapowanie plików bezpośrednio do pamięci (mmap)
        - Cgroups i limity pamięci, parametr swappiness kontroluje, jak agresywnie Linux korzysta z pamięci wymiany (swap)
        - Linux używa technik takich jak prefetching i readahead, aby przewidywać, jakie dane mogą być potrzebne i ładować je wcześniej

    - Python memory optimization technics:
        - object interning / object sharing
        - freelist - reusing memory - or object caching (often used objects), empty dict are reused
        - constant pool (for constant variables in functions)
        - dynamic memory allocation for mutable objects
        - optimization in hash tables (dicts)
        - Lazy Evaluation i View Objects (Python User level)


Python Call Stack (Pythonowy Stos wywołań):
    - W językach niskopoziomowych, takich jak C, stos wywołań jest zarządzany bezpośrednio przez system operacyjny i procesor.
    - W CPython stos wywołań jest zarządzany interpreter:
        - dodaje to narzut, ale umożliwia np dynamiczne zarządzanie pamięcią (stos odpowiada za zarządzanie pamięcią przy wywoływaniu funkcji)

    Jak to umożliwia dynamiczne zarządzanie pamięcią?
     - Ramki wywołań są dynamiczne i nie muszą mieć z góry określonego rozmiaru — stos wywołań dopasowuje się do rozmiaru wywołań funkcji
     - mniejsze zaangażowanie Garbage Collector
         - GC nie działa bezpośrednio na stosie, gdy funkcja kończy działanie, jej lokalne zmienne są usuwane natychmiast (bez interwencji GC).
         - Liczniki referencji Garbage Collector pozwalają na automatyczne usuwanie obiektów, na które wskazywały referencje ze stosu.
    Narzut związany z dynamicznym zarządzaniem pamięcią:
        - Zarządzanie pamięcią przez licznik referencji - działanie Garbage collectora jest kosztowne pod względem czasowym
        - Zastosowanie dynamicznych ramek wywołań również wiąże się z pewnym kosztem pamięci i czasu.
          Tworzenie i usuwanie ramek wywołań przy każdym wywołaniu funkcji ma swój narzut czasowy.

Heap memory in Python:
    - dynamic virtual memory assigned to the given process (logically it is continual address space)
    - used automatically when objects in Python are created
    - global memory space (subspace of heap memory)
    - Garbage Collector dba o zwalnianie pamięci obiektów przechowywanych na stercie.
    - Kiedy obiekt jest nieosiągalny (nie ma referencji do niego), GC usuwa go z pamięci. Jest to zarządzanie dynamiczne.


More about Call Stacks in Python:

- dokładniej w Pythonie/OS funkcjonują dwa stosy:
  - klasyczny stos procesora. C stack (nowy per proces / wątek)
    - Jest to stos na poziomie systemowym, zarządzany przez system operacyjny i procesor.
    - W przypadku Pythona (zwłaszcza CPython), ten stos jest używany przy wywoływaniu funkcji niskopoziomowych napisanych w C.
    - Interpreter Pythona (który jest implementowany w C w CPythonie) korzysta z tego stosu przy wykonywaniu kodu Pythona.

  - Pythonowy Stos wywołań (nowy per proces / wątek)

    - Stos Pythonowy jest realizowany przy pomocy ramek wywołań (PyFrameObject) - zarządzany przez interpreter
    - dokładniej, w CPython stos wywołań i ramki funkcji są zaimplementowane na poziomie kodu źródłowego interpretera w języku C
    - dzieje się to w: Python/ceval.c: w głównej pętla interpretera, gdzie wykonywany jest bytecode i zarządzane są ramki
        - short-living data like local variable references in function scope that are packed in Frames (when functions are called)
        - upraszaczając Stos wywołań bazuje na polu f_back w PyFrameObject, który wskazuje na poprzednią ramkę (rodzica)
        - Każda ramka odpowiada jednemu wywołaniu funkcji (lub blokowi kodu wykonywanemu przez interpreter, np. w module, klasie, itp.)
        - Dzięki tej konstrukcji Python śledzi historię wywołań i pozwala debugować kod (np. tracebacks w przypadku błędów).

        - Ramki funkcji: PyFrameObject - Include/frameobject.h - kluczowe elementy struktury:
            - f_back: Wskaźnik na poprzednią ramkę. Łączy ramki w stos wywołań
            - f_code: Odniesienie do obiektu kodu (bytecode) odpowiadającego funkcji.
            - f_valuestack: Wskaźnik na stos wartości używanych przez bytecode (np. zmienne, wyniki operacji).
            - f_blockstack: Stos bloków try/except i pętli.

            Generatory, yield:
                - struktura PyGenObject, przechowuje wszystkie informacje potrzebne do wznowienia wykonania generatora po każdym yield
                - działanie ramek funkcji oraz stosu wywołań różni się nieco od standardowego działania funkcji
                - dzięki mechanizmowi yield realizowane jest zatrzymywanie i wznawianie funkcji
                  a ramki funkcji generatora są przechowywane między kolejnymi wywołaniami,
                  co pozwala na efektywne zarządzanie pamięcią i realizację leniwego przetwarzania danych
                - Kiedy interpreter napotyka yield, wykonuje następujące kroki:
                    - Zapisuje stan funkcji (ramkę: PyFrameObject) do struktury obiektu generatora (PyGenObject).
                    - Zwraca kontrolę do wywołującego kodu i wartość, którą zdefiniowano przy "yield var_value"

                - Generatory są przydatne w sytuacjach, gdy nie musisz przechowywać wszystkich wartości w pamięci na raz:
                  (Kiedy generator naprawdę oszczędza pamięć?)
                    - Use Case 1: Iterowanie przez wartości bez ich przechowywania (przetwarzanie dużych zbiorów danych)
                    - Use Case 2: Przetwarzanie danych w strumieniu (stream processing)
                    - Use Case 3: Obsługa nieskończonych sekwencji
                    - Use Case 4: Przetwarzanie dużych plików z logami
                        - dzięki generatorowi możesz wczytywać/przetwarzać plik linia po linii bez przechowywania całego pliku w pamięci
                - Istotne - Kiedy generatory nie są potrzebne?
                    - gdy musisz przechowywać wszystkie generowane wartości w pamięci
                    - gdy potrzebujesz wielokrotnego dostępu do wyników (np. musisz iterować przez te same dane wiele razy)

            asyncio, korutyny:
                - Stos Pythonowy, w przypadku korutyn (async def) działa to trochę inaczej
                - każda korutyna ma swój własny kontekst wykonania, który przechowuje dane lokalne i stan wywołania
                - Zamiast typowego stosu ramek funkcji, korutyna "zamraża" swój stan w obiekcie CoroWrapper (zarządzanym przez pętlę zdarzeń)
                    - gdy korutyna jest "zamrażana" Pętla zdarzeń usuwa jej ramkę ze stosu Pythonowego
                    - wznowienie korutyny powoduje również przywrócenie jej ramki na stos Pythonowy
</pre>

            </div>
        </div>
    </div>
</div>



<div class="row">
    <div class="col-md-9">
        <div class="card mb-4 box-shadow" style="background-color: #2222;">
            <div class="card-body">
                <a class="main-a" href="https://docs.python.org/3/library/">The Python Standard Library</a>
                <ul>
                    <li>Introduction</li>
                    <li>Built-in Functions</li>
                    <ul>
                        <li>abs, aiter, all, anext, any, ascii, bin, bool, breakpoint, callable, chr, classmethod, compile, complex,</li>
                        <li>delattr, dir, divmod, enumerate, eval, exec, filter, float, format, getattr, globals, hasattr, hash, help,</li>
                        <li>id, input, int, isinstance, issubclass, iter, len, locals, map, max, min, next, object, oct, open, ord,</li>
                        <li>pow, print, property, repr, reversed, round, setattr, slice, sordeted, staticmethod, sum, super, type, vars, zip, __import__</li>
                    </ul>
                    <li>Built-in Constants</li>
                    <li>Built-in Exceptions</li>
                    <li>Text Processing Services</li>
                    <li>Binary Data Services</li>
                    <li>Data Types</li>
                    <li>Numeric and Mathematical Modules</li>
                    <li>Functional Programming Modules</li>
                    <li>File and Directory Access</li>
                    <li>Data Persistence</li>
                    <li>Data Compression and Archiving</li>
                    <li>File Formats</li>
                    <li>Cryptographic Services</li>
                    <li>Generic Operating System Services</li>
                    <li>Concurrent Execution</li>
                    <li>Networking and Interprocess Communication</li>
                    <li>Internet Data Handling</li>
                    <li>Structured Markup Processing Tools</li>
                    <li>Internet Protocols and Support</li>
                    <li>Multimedia Services</li>
                    <li>Internationalization</li>
                    <li>Program Frameworks</li>
                    <li>Graphical User Interfaces with Tk</li>
                    <li>Development Tools</li>
                    <li>Debugging and Profiling</li>
                    <li>Software Packaging and Distribution</li>
                    <li>Python Runtime Services</li>
                    <li>Custom Python Interpreters</li>
                    <li>Importing Modules</li>
                    <li>Python Language Services</li>
                    <li>MS Windows Specific Services</li>
                    <li>Unix Specific Services</li>
                    <li>Modules command-line interface (CLI)</li>
                    <li>Superseded Modules</li>
                    <li>Removed Modules</li>
                    <li>Security Considerations</li>
                </ul>

            </div>
</div>
</div>
</div>


<div class="row">
    <div class="col-md-9">
        <div class="card mb-4 box-shadow" style="background-color: yellow;">
            <div class="card-body">
                <a href="asyncio.html"><h4 style="font-weight: bold;text-decoration: underline;">Python ayncio library</h4></a>
            </div>
        </div>
    </div>
</div>



<div class="row">
    <div class="col-md-9">
        <div class="card mb-4 box-shadow" style="background-color: #777;">
            <div class="card-body">
                <h4 style="font-weight: bold;text-decoration: underline;">Python garbage collection (GC)</h4>
                <div>It is builtin mechanism for memory management. Main goal is memory recovery.</div>
                <div>From practical point of view it is process of auto-deleting not-used objects from memory. For detecting that objects Python uses:</div>
                <ul>
                    <li><b>Reference counting</b>, mechanism of counting how many times object is used.</li>
                    <li><b>Cycle detection</b>, mechanism for finding object referencing each other.</li>
                </ul>
            </div>
        </div>
    </div>
</div>


<div class="row">
    <div class="col-md-9">
        <div class="card mb-4 box-shadow" style="background-color: #90EE90;">
            <div class="card-body">
                <h4 style="font-weight: bold;text-decoration: underline;">GIL (Global Interpreter Lock)</h4>
                <div>Global Interpreter Lock - mechanism used in CPython, it ensures that in one moment only pone thread can execute Python code.</div>
                <ul>
                    <li>What problems GIL solves for Python?</li>
                    <ul>
                        <li>Multi-threading access potential issues.</li>
                        <li>Race Conditions in Reference Counting (Garbage Collection).</li>
                        <li>Complexity of Fine-Grained Locks. The GIL ensures safety and simplicity.</li>
                    </ul>
                    <li>Why Was the GIL Chosen as the Solution?</li>
                    <ul>
                        <li>Simplicity and performance aspects.</li>
                    </ul>
                    <li>The Impact on Multi-Threaded Python Programs.</li>
                    <ul>
                        <li>Multi-threading in Python doesn't achieve true parallelism on multi-core processors (except in specific cases, like I/O-bound operations or extensions written in C that release the GIL).</li>
                    </ul>
                    <li>Why Hasn’t the GIL Been Removed Yet?</li>
                    <ul>
                        <li>Due to several reasons being a combination of technical complexity, backward compatibility concerns, and trade-offs in performance and simplicity.</li>
                    </ul>
                </ul>
            </div>
        </div>
    </div>
</div>



<div class="row">
    <div class="col-md-9">
        <div class="card mb-4 box-shadow" style="background-color: #CFC0CB;">
            <div class="card-body">
                <h4 style="font-weight: bold;text-decoration: underline;">Metaprogramming / Metaclass</h4>
                <div>Key Concepts in Metaprogramming:</div>
                <ul>
                    <li>Dynamic Class Creation: Creating classes at runtime.</li>
<pre class="code">
Foo = type('Foo', ('FooBase1', 'FooBase2'), {'attr': 100,'attr_val': lambda x : x.attr})
</pre>
                    <li>Decorators: Functions that modify the behavior of other functions or methods or classes.</li>
                    <li><b>Descriptors</b> are objects that manage the access to attributes of other objects.</li>
                    <ul>
                        <li>objects with manipulated dunder methods: __get__, __set__, __delete__</li>
                    </ul>
                    <li>Magic Methods: Special methods that let you control how Python interacts with objects (e.g., __getattr__, __setattr__).</li>
                    <li>exec() and eval(): Functions for dynamic execution of Python code.</li>
                </ul>

                <div>Other aspect of metaprogramming in Python are Custom Metaclasses:</div>
<pre class="code">
    class Meta(type):
        def __new__(cls, name, bases, dct):
            x = super().__new__(cls, name, bases, dct)
            x.attr = 100
            return x

    class Foo(metaclass=Meta):
        pass

>>> Foo.attr
100</pre>
            </div>
        </div>
    </div>
</div>





<div class="row">
    <div class="col-md-9">
        <div class="card mb-4 box-shadow" style="background-color: light-blue;">
            <div class="card-body">
                <h4 style="font-weight: bold;text-decoration: underline;">Descriptors</h4>

<pre class="code">
Descriptors are a powerful, general purpose protocol.
    - If an object defines __set__() or __delete__(), it is considered a data descriptor.
    - They are the mechanism behind properties, methods, static methods, class methods, and super()
        - If an object defines __set__() or __delete__(), it is considered a data descriptor.
        - Descriptors that only define __get__() are called non-data descriptors (they are often used for methods but other uses are possible).
    - Descriptor invocation logic: The mechanism for descriptors is embedded in the __getattribute__() methods for object, type, and super().
        - Overriding __getattribute__() prevents automatic descriptor calls because all the descriptor logic is in that method.
    - __set_name__ - Customized names - The implementation details are in type_new() and set_names() in Objects/typeobject.c

Basic Descriptor protocol:
    __get__(self, obj, objtype) – returns attribute value (can be calculated).
    __set__(self, obj, value) – set attribute value
    __delete__(self, obj) – delete attribute

Mechanics of Descriptor invocation logic:
    - Descriptors are invoked by the __getattribute__() method.
    - Classes inherit this machinery from object, type, or super().
    - object.__getattribute__() and type.__getattribute__() make different calls to __get__().
    - All functions written in Python are descriptors (have __get__), when functions written in C are not.

So, Descriptors Use Cases:
    - mechanism behind properties, bound methods, static methods, class methods, and super()
    also:
    - Dynamics lookups
    - Logged Access
    - Custom Validators
    - Customized attribute names
    - data descriptors could be used to implement an ORM
</pre>
            </div>
        </div>
    </div>
</div>



<div class="row">
    <div class="col-md-9">
        <div class="card mb-4 box-shadow" style="background-color: orange;">
            <div class="card-body">
                <h4 style="font-weight: bold;text-decoration: underline;">Python protocols:</h4>

<pre class="code">
    - Can Python be named protocol oriented language?

    - Class creation protocol
    - Sequence protocol
    - Attribute access protocol
    - Iterable Protocol
    - Numeric Protocol
    - Context Manager protocol
    - Callable protocol
    - Descriptor protocol
    - Buffer protocol
    - Set protocol
    - Async Protocols</pre>
            </div>
        </div>
    </div>
</div>


</body>
</html>


