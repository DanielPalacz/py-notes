<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Bootstrap CSS -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">

    <style>
    * {
      box-sizing: border-box;
      font-family: 'Montserrat', sans-serif;
    }

    table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
    }
    th, td {
      padding: 5px;
      text-align: left;
    }
    .main-a {
      font-size: 30px;
<!--      color: #000;-->
    }
    .row {
        margin: 20px 20px 20px 20px
    }


    .button-link-custom {
        font-size:30px;
    }

    .button-link-custom:hover {
        transform: scale(1.02); /* Slightly enlarge the brand */
        box-shadow: 0px 6px 12px rgba(0, 0, 0, 0.2);
        color: yellow;
    }



    .card {
        background-color: #d0e7f7;
        border-radius: 8px;
        transition: all 0.3s ease;
        box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1);
        border: 2px solid #000;
    }

    .card:hover {
        transform: scale(1.02); /* Slightly enlarge the brand */
        box-shadow: 0px 6px 12px rgba(0, 0, 0, 0.2);
    }

    .card-body {
		padding: 0px;            /* Internal padding */
		margin: 10px;            /* Internal margin */
		color: #000;
    }

    .card-body a {
		color: #000;
		text-decoration: underline;
    }

    .shell {
    	color: #555;
    }

    .code {
    	color: green;
    	font-style: italic;
    }

    .todo {
        color: yellow;
        background-color: #000;
    }
    .yellow-this {
        background-color: yellow;
    }
    .green-this {
        background-color: #90EE90;
    }

    .notion {
    	color: #9370DB;
    	font-style: italic;
<!--    	font-weight: bold;-->
    }

    .notion-explanation {
    	color: #9370DB;
    	font-style: italic;
    }

        #hiddenTekst {
            display: none;
        }
        button {
            cursor: pointer;
        }

</style>

</head>
<body style="color:black;background-color:powderblue;">



<div class="row">
    <div class="col-md-8">
        <div class="card mb-4 box-shadow">
            <div class="card-body">
                <h4 style="font-weight: bold;text-decoration: underline;">Introduction:</h4>
                <div>Async IO is a concurrent programming design that has received dedicated support in Python, evolving rapidly from Python 3.4 through 3.7, and probably beyond. In the one sentence <b>asyncio</b> is a package to write concurrent code using the async/await syntax.</div>
                <ul>
                    <li>async is used to define a coroutine (an async function)</li>
                    <li>await is used to pause execution of a coroutine until an awaited result is ready.</li>
                </ul>
                <div>coroutine (an async function)</div>
                <ul>
                    <li>it is essentially a function that can pause and resume execution. When you call a coroutine, it doesn't immediately run; it returns a coroutine object.</li>
                </ul>
                <div>To execute coroutine, you need to:</div>
                <ul>
                    <li>Use await if you're inside an async function.</li>
                    <li>Use an event loop like asyncio.run() if you're in a synchronous context.</li>
                </ul>
            </div>
        </div>
    </div>
        <div class="col-md-3">
        <div class="card mb-4 box-shadow yellow-this">
            <div class="card-body">
                <h4 style="font-weight: bold;text-decoration: underline;">Note:</h4>
                <div>- the term <b>async IO</b> to denote the language-agnostic design of asynchronous IO</div>
                <div> - while <b>asyncio</b> refers to Python package</div>
            </div>
        </div>
    </div>
</div>


<br>

<div class="row">
    <div class="col-md-8">
        <div class="card mb-4 box-shadow">
            <div class="card-body">
                <h4 style="font-weight: bold;text-decoration: underline;">View of Async IO in Concurrency world:</h4>
                <br>
                <div>Where Does Async IO Fit In?</div>
                <br>
                <ul>
                    <li><b>Parallelism</b> consists of performing multiple operations at the same time.</li>
                    <li><b>Multiprocessing</b> is a means to effect parallelism, and it entails spreading tasks over a computer’s central processing units (CPUs, or cores). Multiprocessing is well-suited for CPU-bound tasks: tightly bound for loops and mathematical computations usually fall into this category.</li>
                    <li><b>Concurrency</b> is a slightly broader term than parallelism. It suggests that multiple tasks have the ability to run in an overlapping manner. (There’s a saying that concurrency does not imply parallelism.)</li>
                    <li><b>Threading</b> is a concurrent execution model whereby multiple threads take turns executing tasks. One process can contain multiple threads. Python has a complicated relationship with threading thanks to its GIL. What’s important to know about threading is that it’s better for IO-bound tasks. While a CPU-bound task is characterized by the computer’s cores continually working hard from start to finish, an IO-bound job is dominated by a lot of waiting on input/output to complete.</li>
                    <ul>
                        <li>To recap the above, concurrency encompasses both multiprocessing (ideal for CPU-bound tasks) and threading (suited for IO-bound tasks). Multiprocessing is a form of parallelism, with parallelism being a specific type (subset) of concurrency. The Python standard library has offered longstanding support for both of these through its multiprocessing, threading, and concurrent.futures packages.</li>
                    </ul>
                    <br>
                    <li>Other concept, <b>asynchronous IO</b> enabled through the standard library’s <b>asyncio</b> package and the new async and await language keywords:</li>
                    <ul>
                        <li>The asyncio package is billed by the Python documentation as a library to write concurrent code. However, async IO is not threading, nor is it multiprocessing. It is not built on top of either of these.</li>
                        <li>In fact, async IO is a single-threaded, single-process design: it uses <b>cooperative multitasking</b>, a term that you’ll flesh out by the end of this tutorial. It has been said in other words that async IO gives a feeling of concurrency despite using a single thread in a single process. Coroutines (a central feature of async IO) can be scheduled concurrently, but they are not inherently concurrent.</li>
                        <li>To reiterate, async IO is a style of concurrent programming, but it is not parallelism. It’s more closely aligned with threading than with multiprocessing but is very much distinct from both of these and is a standalone member in concurrency’s bag of tricks.</li>
                        <li>That leaves one more term. What does it mean for something to be asynchronous? This isn’t a rigorous definition, but for our purposes here, I can think of two properties:</li>
                    <ul>
                        <li>Asynchronous routines are able to “pause” while waiting on their ultimate result and let other routines run in the meantime.</li>
                        <li>Asynchronous code, through the mechanism above, facilitates concurrent execution. To put it differently, asynchronous code gives the look and feel of concurrency.</li>
                    </ul>
                    </ul>
                </ul>

                <div>Async IO Explained</div>
                <ul>
                    <li><b>Cooperative multitasking</b> is a fancy way of saying that a program’s event loop communicates with multiple tasks to let each take turns running at the optimal time.</li>
                </ul>
                <div>Async IO Is Not Easy</div>
                <ul>
                    <li>Python’s async model is built around concepts such as callbacks, events, transports, protocols, and futures.</li>
                </ul>
            </div>
        </div>
    </div>
</div>



<div class="row">
    <div class="col-md-10">
        <div class="card mb-4 box-shadow yellow-this">
            <div class="card-body">
                <h1 style="font-weight: bold;text-decoration: underline;">Questions</h1>
                <br>
                <div><b>1a. What is Event Loop and how is created?</b></div>
<!--                <button onclick="pokazTekst()">Show/hide answer</button></div>-->
                <ul>
                    <li>Main and central mechanism of asyncio package. It is responsible for managing coroutines execution and handling event in asynchronous application.</li>
                    <li>Event loop allows to halt and start again coroutines. Because of this many tasks can be executed simultaneously.</li>
                    <li>Commonly Event loop is created as below when it creates Event loop and trigger coroutine.</li>
                        <b><span class="code">asyncio.run(coroutine_function())</span></b>
                    <li>More complex way:</li>
                    <pre class="code">loop = asyncio.get_event_loop()
loop.run_until_complete(coroutine_function())</pre>
                </ul>

                <br>
                <div><b>1b. How to define asynchronous function in Python?</b></div>
                <ul>
                    <pre class="code">
async def fetch_data():
    data = await some_network_request()
    return data</pre>
                    <li>How to trigger async function?</li>
                    <ul>
                    <pre class="code">
# from other coroutine function:
async def main():
    result = await coroutine_funct()
    print(result)

# from synchronous context:
asyncio.run(coroutine_funct())
                    </pre>
                    </ul>
                </ul>

                <div><b>2a. What is basic task for await keyword in asyncio?</b></div>
                <ul>
                    <li>It halts execution of current coroutine and allows other Event loop tasks to be executed. Because of this all program is not blocked.</li>
                    <li>await also waits for finishing execution of awaitable object (other async function)</li>
                    <li>await works only in async context in function defined by async. When used in synchronous context then SyntaxError is raised.</li>
                </ul>


                <div><b>2b. What happen if you forget to use await keyword when calling async function</b></div>
                <ul>
                    <li>Coroutine object will be created but not executed.</li>
                    <pre class="code">
import asyncio

async def fetch_data():
    print("Fetching data...")
    await asyncio.sleep(2)
    print("Data fetched!")

async def main():
    fetch_data()  # Brak await
    print("This will print immediately")

asyncio.run(main())</pre>
                    <li>fetch_data() returns coroutine object, but will not be executed</li>
                    <li>Also, RuntimeWarning will be triggered (starting from Python 3.8)</li>
                    <pre class="code">
RuntimeWarning: coroutine 'fetch_data' was never awaited</pre>
                </ul>



                <div><b>3a. How to create and start task in asyncio</b></div>
                <ul>
                    <li>Task it is object of class: '_asyncio.Task' created by asyncio.create_task(). It manages coroutine execution.</li>
                    <li>When task is created then automatically coroutine is started in background.</li>
                    <pre class="code">

async def my_coroutine():
    print("Start")
    await asyncio.sleep(1)
    print("End")

async def main():
    task = asyncio.create_task(my_coroutine())
    print("Task created")
    await task

asyncio.run(main())
</pre>
                    <li>Differences between task and coroutine</li>
                    <table>
                        <thead>
                            <th>Feature</th>
                            <th>Coroutine</th>
                            <th>Task</th>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Trigerring</td>
                                <td>Not automatically</td>
                                <td>Coroutine is triggered immediately in background.</td>
                            </tr>
                            <tr>
                                <td>Parallelism</td>
                                <td>Executes in the context of the current await / Event loop</td>
                                <td>It is tool allowing coroutine to be executed parallel.</td>
                            </tr>
                            <tr>
                                <td>State</td>
                                <td>Lack of self-monitoring capabilities</td>
                                <td>Task has self-monitoring features.</td>
                            </tr>
                        </tbody>
                    </table>
                </ul>

                <div><b>2b. What is difference beetwen asyncio.run and loop.run_until_complete?</b></div>
<!--                <button onclick="pokazTekst()">Show/hide answer</button></div>-->
                <div>asyncio.run()</div>
                <ul>
                    <li>Create new Event loop.</li>
                    <li>Executes the given coroutine.</li>
                    <li>When coroutine is finished it closes Event loop and clean resources.</li>
                    <li>Event loop is automatically managed.</li>
                    <li>Easy to use, but can be used only only once in the program.</li>
                </ul>
                <div>loop.run_until_complete()</div>
                <ul>
                    <li>More complex to use.</li>
                </ul>

                <div><b>3a. How to create and run more tasks in parallel?</b></div>
<!--                <button onclick="pokazTekst()">Show/hide answer</button></div>-->
                <ul>
                    <li>asyncio.gather()</li>
                    <li>asyncio.create_task() => should be run in some loop because only 1 task can be created by call</li>
                </ul>

                <div><b>3b. What is difference between 'asyncio.gather()' and 'asyncio.create_task()'?</b></div>
                <pre class="code">
    import asyncio

    async def task1():
        await asyncio.sleep(1)
        print("Task 1 done")

    async def task2():
        await asyncio.sleep(2)
        print("Task 2 done")

    async def task3():
        await asyncio.sleep(3)
        print("Task 3 done")

    async def main():
        # Uruchamiamy wszystkie zadania jednocześnie i czekamy na ich zakończenie
        await asyncio.gather(task1(), task2(), task3())

    # Uruchomienie event loop
    asyncio.run(main())</pre>
            <ul>
                <li>await asyncio.gather() - multiple task run in one call</li>
                <li>asyncio.create_task() => it creates spacial objects (Tasks) that start coroutine immediately. It should be run in some loop because only 1 task can be created by call</li>
            </ul>
            </div>

        </div>
    </div>
</div>








    <script>
        function pokazTekst() {
            const tekst = document.getElementById('hiddenTekst');
            if (tekst.style.display === 'none') {
                tekst.style.display = 'block'; // Pokaż tekst
            } else {
                tekst.style.display = 'none'; // Schowaj tekst
            }
        }
    </script>

</body>
</html>


